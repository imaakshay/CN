#include "ns3/core-module.h"
#include "ns3/network-module.h"
#include "ns3/internet-module.h"
#include "ns3/point-to-point-module.h"
#include "ns3/applications-module.h"
#include "ns3/traffic-control-module.h"
using namespace ns3;
NS_LOG_COMPONENT_DEFINE ("Lab-Program-1");
int main (int argc, char *argv[])
{
std::string socketType= "ns3::TcpSocketFactory";;
CommandLine cmd ;
cmd .Parse (argc, argv);
NodeContainer nodes ;
nodes .Create (3); //3 point-to-point nodes are created
InternetStackHelper stack ;
stack .Install (nodes); //TCP-IP layer functionality configured on all nodes
//Bandwidth and delay set for the point-to-point channel. Vary these parameters to //see the
variation in number of packets sent/received/dropped.
PointToPointHelper p2p1 ;
p2p1 .SetDeviceAttribute ("DataRate", StringValue ("5Mbps"));
p2p1 .SetChannelAttribute ("Delay", StringValue ("1ms"));
//Set the base address for the first network(nodes n0 and n1)
Ipv4AddressHelper address ;
address .SetBase ("10.1.1.0", "255.255.255.0");
NetDeviceContainer devices ;
devices = p2p1.Install (nodes.Get (0), nodes.Get (1));
Ipv4InterfaceContainer interfaces = address.Assign (devices);
//Set the base address for the second network(nodes n1 and n2)
devices = p2p1 .Install (nodes.Get (1), nodes.Get (2));
address.SetBase ("10.1.2.0", "255.255.255.0"); interfaces =
address.Assign (devices);
//RateErrorModel allows us to introduce errors into a Channel at a given rate . //Vary the
error rate value to see the variation in number of packets dropped
Ptr<RateErrorModel> em = CreateObject<RateErrorModel> ();
em->SetAttribute ("ErrorRate", DoubleValue (0.00002));
devices.Get (1)->SetAttribute ("ReceiveErrorModel", PointerValue (em));
//create routing table at all nodes
Ipv4GlobalRoutingHelper::PopulateRoutingTables ();
uint32_t payloadSize = 1448;
OnOffHelper onoff (socketType, Ipv4Address::GetAny ());
//Generate traffic by using OnOff application
onoff .SetAttribute ("OnTime", StringValue
("ns3::ConstantRandomVariable[Constant=1]"));
onoff .SetAttribute ("OffTime", StringValue
("ns3::ConstantRandomVariable[Constant=0]"));
onoff .SetAttribute ("PacketSize", UintegerValue (payloadSize));
onoff .SetAttribute ("DataRate", StringValue ("50Mbps")); //bit/s
uint16_t port = 7;
//Install receiver (for packetsink) on node 2
Address localAddress1 (InetSocketAddress (Ipv4Address::GetAny (), port));
PacketSinkHelper packetSinkHelper1 (socketType, localAddress1);
ApplicationContainer sinkApp1 = packetSinkHelper1.Install (nodes.Get (2));
sinkApp1.Start (Seconds (0.0));
sinkApp1.Stop (Seconds (10));
//Install sender app on node 0
ApplicationContainer apps ;
AddressValue remoteAddress (InetSocketAddress (interfaces.GetAddress (1), port));
onoff .SetAttribute ("Remote", remoteAddress);
apps .Add (onoff.Install (nodes.Get (0)));
apps .Start (Seconds (1.0)); apps .Stop
(Seconds (10));
Simulator::Stop (Seconds (10));
AsciiTraceHelper ascii;
p2p1 .EnableAsciiAll (ascii.CreateFileStream ("lab1.tr"));
//Run the simulator
Simulator::Run ();
Simulator::Destroy ();
return 0;
}

//Second program
#include <iostream>
#include "ns3/core-module.h"
#include "ns3/network-module.h"
#include "ns3/csma-module.h"
#include "ns3/applications-module.h"
#include "ns3/internet-apps-module.h"
#include "ns3/internet-module.h"
using namespace ns3;
NS_LOG_COMPONENT_DEFINE ("Lab-Program-2");
static void PingRtt (std::string context, Time rtt)
{
std::cout << context <<""<< rtt << std::endl;
}
int main (int argc, char *argv[])
{
CommandLine cmd ;
cmd .Parse (argc, argv);
/ Here, we will explicitly create six nodes.
NS_LOG_INFO ("Create nodes.");
NodeContainer c ;
c .Create (6);
/ connect all our nodes to a shared channel.
NS_LOG_INFO ("Build Topology."); CsmaHelper
csma ;
csma .SetChannelAttribute ("DataRate", DataRateValue (DataRate (10000)));
csma .SetChannelAttribute ("Delay", TimeValue (MilliSeconds (0.2)));
NetDeviceContainer devs = csma .Install (c);
/ add an ip stack to all nodes.
NS_LOG_INFO ("Add ip stack.");
InternetStackHelper ipStack ;
ipStack .Install (c);
// assign ip addresses
NS_LOG_INFO ("Assign ip addresses.");
Ipv4AddressHelper ip ;
ip .SetBase ("192.168.1.0", "255.255.255.0");
Ipv4InterfaceContainer addresses = ip.Assign (devs);
NS_LOG_INFO ("Create Sink.");
/ Create an OnOff application to send UDP datagrams from node zero to node 1.
NS_LOG_INFO ("Create Applications.");
uint16_t port = 9; // Discard port (RFC 863)
OnOffHelper onoff ("ns3::UdpSocketFactory",
Address (InetSocketAddress (addresses.GetAddress (2), port)));
onoff .SetConstantRate (DataRate ("500Mb/s"));
ApplicationContainer app = onoff.Install (c.Get (0));
/ Start the application
app .Start (Seconds (6.0));
app .Stop (Seconds (10.0));
/ Create an optional packet sink to receive these packets
PacketSinkHelper sink ("ns3::UdpSocketFactory",
Address (InetSocketAddress (Ipv4Address::GetAny (), port))); app =
sink .Install (c.Get (2));
app .Start (Seconds (0.0));
NS_LOG_INFO ("Create pinger");
V4PingHelper ping = V4PingHelper (addresses.GetAddress (2));
NodeContainer pingers ;
pingers .Add (c.Get (0));
pingers .Add (c.Get (1));
ApplicationContainer apps ;
apps = ping .Install ( pingers );
apps .Start (Seconds (1.0));
apps .Stop (Seconds (5.0));
// finally, print the ping rtts.
Config::Connect ("/NodeList/*/ApplicationList/*/$ns3::V4Ping/Rtt",
MakeCallback (&PingRtt));
NS_LOG_INFO ("Run Simulation.");
AsciiTraceHelper ascii;
csma .EnableAsciiAll (ascii.CreateFileStream ("ping1.tr"));
Simulator::Run ();
Simulator::Destroy ();
NS_LOG_INFO ("Done.");
}

//Third program
#include "ns3/core-module.h"
#include "ns3/network-module.h"
#include "ns3/internet-module.h"
#include "ns3/point-to-point-module.h"
#include "ns3/applications-module.h"
#include <iostream>
#include "ns3/csma-module.h"
using namespace ns3;
NS_LOG_COMPONENT_DEFINE ("3rd Lab Program");
//MyApp class inherits the ns-3 Application class defined in
//src/network/model/application.h.
//The MyApp class is obligated to override the StartApplication and //StopApplication
methods. These methods are automatically called when MyApp is //required to start and stop
sending data during the simulation.
class MyApp : public Application
{
public:
MyApp ();
virtual ~MyApp();
void Setup (Ptr<Socket> socket, Address address, uint32_t packetSize, uint32_t nPackets,
DataRate dataRate);
private:
virtual void StartApplication (void);
virtual void StopApplication (void);
void ScheduleTx (void);
void SendPacket (void);
Ptr<Socket> m_socket;
Address m_peer;
uint32_t m_packetSize;
uint32_t m_nPackets;
DataRate m_dataRate;
EventId m_sendEvent;
bool m_running;
uint32_t m_packetsSent;
};
MyApp::MyApp () // constructor
: m_socket (0),
m_peer (),
m_packetSize (0),
m_nPackets (0),
m_dataRate (0),
m_sendEvent (),
m_running (false),
m_packetsSent (0)
{
}
MyApp::~MyApp() // destructor
{
m_socket = 0;
}
// initialize member variables.
void MyApp::Setup (Ptr<Socket> socket, Address address, uint32_t packetSize,
uint32_t nPackets, DataRate dataRate)
{
m_socket = socket;
m_peer = address;
m_packetSize = packetSize;
m_nPackets = nPackets;
m_dataRate = dataRate;
}
/ Below code is the overridden implementation of Application::StartApplication. It //does a
socket bind operation and establishes TCP connection with the address //specified in m_peer.
void MyApp::StartApplication (void)
{
m_running = true;
m_packetsSent = 0;
m_socket->Bind ();
m_socket->Connect (m_peer);
SendPacket ();
}
//The next bit of code explains to the Application how to stop creating simulation //events.
void MyApp::StopApplication (void)
{
m_running = false;
if (m_sendEvent.IsRunning ())
{
Simulator::Cancel (m_sendEvent);
}
if (m_socket)
{
m_socket->Close ();
}
}
//StartApplication calls SendPacket to start the chain of events that describes the
//Application behavior.
void MyApp::SendPacket (void)
{
Ptr<Packet> packet = Create<Packet> (m_packetSize);
m_socket->Send (packet);
if (++m_packetsSent < m_nPackets)
{
ScheduleTx ();
}
}
//It is the responsibility of the Application to keep scheduling the chain of //events, so
the next lines call ScheduleTx to schedule another transmit event //( a SendPacket ) until
the Application decides it has sent enough.
void MyApp::ScheduleTx (void)
{
if (m_running)
{
Time tNext (Seconds (m_packetSize * 8 / static_cast<double> (m_dataRate.GetBitRate ())));
m_sendEvent = Simulator::Schedule (tNext, &MyApp::SendPacket, this);
}
}
//Below function logs the current simulation time and the new value of the
congestion window every time it is changed.
static void CwndChange (uint32_t oldCwnd, uint32_t newCwnd)
{
NS_LOG_UNCOND (Simulator::Now ().GetSeconds () <<"\t"<< newCwnd);
}
//trace sink to show where packets are dropped
static void RxDrop (Ptr<const Packet> p)
{
NS_LOG_UNCOND ("RxDrop at "<< Simulator::Now ().GetSeconds ());
}
//main function
int main (int argc, char *argv[])
{
CommandLine cmd ;
cmd .Parse (argc, argv);
NS_LOG_INFO ("Create nodes.");
NodeContainer nodes ;
nodes .Create (4); //4 csma nodes are created
CsmaHelper csma ;
csma .SetChannelAttribute ("DataRate", StringValue ("5Mbps"));
csma .SetChannelAttribute ("Delay", TimeValue (MilliSeconds (0.0001)));
NetDeviceContainer devices ;
devices = csma .Install (nodes);
//RateErrorModel allows us to introduce errors into a Channel at a given rate .
Ptr<RateErrorModel> em = CreateObject<RateErrorModel> ();
em ->SetAttribute ("ErrorRate", DoubleValue (0.00001));
devices .Get (1)->SetAttribute ("ReceiveErrorModel", PointerValue (em));
InternetStackHelper stack ;
stack .Install (nodes);
Ipv4AddressHelper address ;
address .SetBase ("10.1.1.0", "255.255.255.0");
Ipv4InterfaceContainer interfaces = address.Assign (devices);
uint16_t sinkPort = 8080;
//PacketSink Application is used on the destination node to receive TCP connections //and
data.
Address sinkAddress (InetSocketAddress (interfaces.GetAddress (1), sinkPort));
PacketSinkHelper packetSinkHelper ("ns3::TcpSocketFactory", InetSocketAddress
(Ipv4Address::GetAny (), sinkPort));
ApplicationContainer sinkApps = packetSinkHelper.Install (nodes.Get (1));
sinkApps .Start (Seconds (0.));
sinkApps .Stop (Seconds (20.));
//next two lines of code will create the socket and connect the trace source.
Ptr<Socket> ns3TcpSocket = Socket::CreateSocket (nodes.Get (0),
TcpSocketFactory::GetTypeId ());
ns3TcpSocket->TraceConnectWithoutContext ("CongestionWindow", MakeCallback
(&CwndChange));
//creates an Object of type MyApp
Ptr<MyApp> app = CreateObject<MyApp> ();
//tell the Application what Socket to use, what address to connect to, how much //data to
send at each send event, how many send events to generate and the rate at //which to
produce data from those events.
app->Setup (ns3TcpSocket, sinkAddress, 1040, 1000, DataRate ("50Mbps"));
nodes.Get (0)->AddApplication (app); app->SetStartTime (Seconds (1.));
app->SetStopTime (Seconds (20.));
devices .Get (1)->TraceConnectWithoutContext ("PhyRxDrop", MakeCallback (&RxDrop));
Simulator::Stop (Seconds (20));
Simulator::Run ();
Simulator::Destroy ();
return 0;
}

//Fourth program
#include "ns3/core-module.h"
#include "ns3/point-to-point-module.h"
#include "ns3/network-module.h"
#include "ns3/applications-module.h"
#include "ns3/wifi-module.h"
#include "ns3/mobility-module.h"
#include "ns3/internet-module.h"
using namespace ns3;
NS_LOG_COMPONENT_DEFINE ("ThirdScriptExample");
int main (int argc, char *argv[])
{
bool verbose = true;
uint32_t nWifi = 3; // 3 wi-fi nodes are created
CommandLine cmd;
cmd.AddValue ("nWifi", "Number of wifi STA devices", nWifi);
cmd.AddValue ("verbose", "Tell echo applications to log if true", verbose); cmd.Parse
(argc,argv);
if (verbose)
{
LogComponentEnable ("UdpEchoClientApplication", LOG_LEVEL_INFO);
LogComponentEnable ("UdpEchoServerApplication", LOG_LEVEL_INFO); }
NodeContainer p2pNodes ;
p2pNodes .Create (2); // 2 nodes are n0,n1 are created
PointToPointHelper pointToPoint ;
pointToPoint .SetDeviceAttribute ("DataRate", StringValue ("5Mbps"));
pointToPoint .SetChannelAttribute ("Delay", StringValue ("2ms"));
NetDeviceContainer p2pDevices ;
p2pDevices = pointToPoint .Install (p2pNodes);
NodeContainer wifiStaNodes ;
wifiStaNodes .Create (nWifi);
NodeContainer wifiApNode = p2pNodes .Get (0);// 1 st node of p2p is also access point
/ default PHY layer configuration is used for wifi
YansWifiChannelHelper channel = YansWifiChannelHelper::Default ();
YansWifiPhyHelper phy = YansWifiPhyHelper::Default (); phy .SetChannel
(channel.Create ());
WifiHelper wifi ;
wifi .SetRemoteStationManager ("ns3::AarfWifiManager");//AARF= rate control algorithm
WifiMacHelper mac ;
Ssid ssid = Ssid ("ns-3-ssid");// ssid=service set identifier in 802.11
mac .SetType ("ns3::StaWifiMac",
"Ssid", SsidValue (ssid),
"ActiveProbing", BooleanValue (false));
NetDeviceContainer staDevices ;
staDevices = wifi .Install (phy, mac, wifiStaNodes);
mac .SetType ("ns3::ApWifiMac","Ssid", SsidValue (ssid));
NetDeviceContainer apDevices ;
apDevices = wifi .Install (phy, mac, wifiApNode);
MobilityHelper mobility ;
/ 2 dimensional grid to initially place sta(stationary nodes)
mobility .SetPositionAllocator ("ns3::GridPositionAllocator", "MinX",
DoubleValue (10.0),
"MinY", DoubleValue (-10.0), "DeltaX",
DoubleValue (7.0), "DeltaY",
DoubleValue (12.0), "GridWidth",
UintegerValue (3), "LayoutType",
StringValue ("RowFirst"));
mobility .SetMobilityModel ("ns3::RandomWalk2dMobilityModel",
"Bounds",RectangleValue (Rectangle (-50, 50, -50, 50)));
mobility .Install (wifiStaNodes);
mobility .SetMobilityModel ("ns3::ConstantPositionMobilityModel");
mobility .Install ( wifiApNode );
InternetStackHelper stack ;
stack .Install ( p2pNodes .Get(1));// stack installed on n1 of p2p
stack .Install ( wifiApNode ); //stack installed on access point
stack .Install ( wifiStaNodes ); //stack installed on mobile nodes
Ipv4AddressHelper address ;
address .SetBase ("10.1.1.0", "255.255.255.0");
Ipv4InterfaceContainer p2pInterfaces ; p2pInterfaces =
address .Assign (p2pDevices);
address .SetBase ("10.1.3.0", "255.255.255.0");
address .Assign ( staDevices ); address .Assign
( apDevices );
//install echo server application on n1
UdpEchoServerHelper echoServer (9);
ApplicationContainer serverApps = echoServer .Install (p2pNodes.Get (1));
serverApps .Start (Seconds (1.0));
serverApps .Stop (Seconds (10.0));
//install echo client application on n3
UdpEchoClientHelper echoClient (p2pInterfaces.GetAddress (1), 9);
echoClient .SetAttribute ("MaxPackets", UintegerValue (1));
echoClient .SetAttribute ("Interval", TimeValue (Seconds (1.0)));
echoClient .SetAttribute ("PacketSize", UintegerValue (1024));
ApplicationContainer clientApps =
echoClient .Install (wifiStaNodes.Get (nWifi - 1));
clientApps .Start (Seconds (2.0)); clientApps .Stop (Seconds
(10.0));
Ipv4GlobalRoutingHelper::PopulateRoutingTables ();
Simulator::Stop (Seconds (10.0));
AsciiTraceHelper ascii;
pointToPoint.EnableAsciiAll (ascii.CreateFileStream ("Tracefilewifides.tr")); phy.EnableAsciiAll
(ascii.CreateFileStream ("Tracefilewifisrc.tr"));
Simulator::Run ();
Simulator::Destroy ();
return 0;
}

//Fifth program
#include "ns3/lte-helper.h"
#include "ns3/epc-helper.h"
#include "ns3/core-module.h"
#include "ns3/network-module.h"
#include "ns3/ipv4-global-routing-helper.h"
#include "ns3/internet-module.h"
#include "ns3/mobility-module.h"
#include "ns3/lte-module.h"
#include "ns3/applications-module.h"
#include "ns3/point-to-point-helper.h"
#include "ns3/config-store.h"
//#include "ns3/gtk-config-store.h"
//.............................................................................................................
using namespace ns3;
NS_LOG_COMPONENT_DEFINE ("EpcFirstExample");
int
main (int argc, char *argv[])
{
uint16_t numberOfNodes = 2; // numberOfNodes = 6 for CDMA
double simTime = 1.1;
double distance = 60.0;
double interPacketInterval = 100;
// Command line arguments
CommandLine cmd;
cmd.Parse(argc, argv);
Ptr<LteHelper> lteHelper = CreateObject<LteHelper> ();
//This will instantiate some common objects (e.g., the Channel object) and provide the
methods to add eNBs and UEs and configure them.
Ptr<PointToPointEpcHelper> epcHelper = CreateObject<PointToPointEpcHelper> ();
//PointToPointEpcHelper, which implements an EPC based on point-to-point links.
//EpcHelper will also automatically create the PGW node and configure it so that it can
properly handle traffic from/to the LTE radio access network.
lteHelper->SetEpcHelper (epcHelper);
//Then, you need to tell the LTE helper that the EPC will be used:
ConfigStore inputConfig
inputConfig.ConfigureDefaults();
//Specify configuration parameters of the objects that are being used for the simulation
// parse again so you can override default values from the command line
cmd.Parse(argc, argv);
Ptr<Node> pgw = epcHelper->GetPgwNode ();
//EpcHelper will also automatically create the PGW node and configure it so that it can
properly handle traffic from/to the LTE radio access network.
// Create a single RemoteHost
NodeContainer remoteHostContainer;
remoteHostContainer.Create (1);
Ptr<Node> remoteHost = remoteHostContainer.Get (0);
InternetStackHelper internet;
internet.Install (remoteHostContainer);
// Create the Internet
PointToPointHelper p2ph;
p2ph.SetDeviceAttribute ("DataRate", DataRateValue (DataRate ("100Gb/s")));
p2ph.SetDeviceAttribute ("Mtu", UintegerValue (1500));
p2ph.SetChannelAttribute ("Delay", TimeValue (Seconds (0.010)));
NetDeviceContainer internetDevices = p2ph.Install (pgw, remoteHost);
Ipv4AddressHelper ipv4h;
ipv4h.SetBase ("1.0.0.0", "255.0.0.0");
Ipv4InterfaceContainer internetIpIfaces = ipv4h.Assign (internetDevices);
// interface 0 is localhost, 1 is the p2p device
Ipv4Address remoteHostAddr = internetIpIfaces.GetAddress (1);
Ipv4StaticRoutingHelper ipv4RoutingHelper;
Ptr<Ipv4StaticRouting> remoteHostStaticRouting = ipv4RoutingHelper.GetStaticRouting
(remoteHost->GetObject<Ipv4> ());
remoteHostStaticRouting->AddNetworkRouteTo (Ipv4Address ("7.0.0.0"), Ipv4Mask
("255.0.0.0"), 1);
NodeContainer ueNodes;
NodeContainer enbNodes;
enbNodes.Create(numberOfNodes);
ueNodes.Create(numberOfNodes);
// Install Mobility Model
Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator> ();
for (uint16_t i = 0; i < numberOfNodes; i++)
{
positionAlloc->Add (Vector(distance * i, 100, 100));
}
MobilityHelper mobility;
mobility.SetMobilityModel("ns3::ConstantPositionMobilityModel");
mobility.SetPositionAllocator(positionAlloc);
mobility.Install(enbNodes);
mobility.Install(ueNodes);
// Install LTE Devices to the nodes
NetDeviceContainer enbLteDevs = lteHelper->InstallEnbDevice (enbNodes);
NetDeviceContainer ueLteDevs = lteHelper->InstallUeDevice (ueNodes);
// Install the IP stack on the UEs
internet.Install (ueNodes);
Ipv4InterfaceContainer ueIpIface;
ueIpIface = epcHelper->AssignUeIpv4Address (NetDeviceContainer (ueLteDevs));
// Assign IP address to UEs, and install applications
for (uint32_t u = 0; u < ueNodes.GetN (); ++u)
{
Ptr<Node> ueNode = ueNodes.Get (u);
// Set the default gateway for the UE
Ptr<Ipv4StaticRouting> ueStaticRouting = ipv4RoutingHelper.GetStaticRouting (ueNode
->GetObject<Ipv4> ());
ueStaticRouting->SetDefaultRoute (epcHelper->GetUeDefaultGatewayAddress (), 1);
}
// Attach one UE per eNodeB
for (uint16_t i = 0; i < numberOfNodes; i++)
{
lteHelper->Attach (ueLteDevs.Get(i), enbLteDevs.Get(i));
// side effect: the default EPS bearer will be activated
}
// Install and start applications on UEs and remote host
uint16_t dlPort = 1234;
uint16_t ulPort = 2000;
uint16_t otherPort = 3000;
ApplicationContainer clientApps;
ApplicationContainer serverApps;
for (uint32_t u = 0; u < ueNodes.GetN (); ++u)
{
++ulPort;
++otherPort;
PacketSinkHelper dlPacketSinkHelper ("ns3::UdpSocketFactory", InetSocketAddress
(Ipv4Address::GetAny (), dlPort));
PacketSinkHelper ulPacketSinkHelper ("ns3::UdpSocketFactory", InetSocketAddress
(Ipv4Address::GetAny (), ulPort));
PacketSinkHelper packetSinkHelper ("ns3::UdpSocketFactory", InetSocketAddress
(Ipv4Address::GetAny (), otherPort));
serverApps.Add (dlPacketSinkHelper.Install (ueNodes.Get(u)));
serverApps.Add (ulPacketSinkHelper.Install (remoteHost));
serverApps.Add (packetSinkHelper.Install (ueNodes.Get(u)));
UdpClientHelper dlClient (ueIpIface.GetAddress (u), dlPort);
dlClient.SetAttribute ("Interval", TimeValue (MilliSeconds(interPacketInterval)));
dlClient.SetAttribute ("MaxPackets", UintegerValue(1000000));
UdpClientHelper ulClient (remoteHostAddr, ulPort);
ulClient.SetAttribute ("Interval", TimeValue (MilliSeconds(interPacketInterval)));
ulClient.SetAttribute ("MaxPackets", UintegerValue(1000000));
UdpClientHelper client (ueIpIface.GetAddress (u), otherPort);
client.SetAttribute ("Interval", TimeValue (MilliSeconds(interPacketInterval)));
client.SetAttribute ("MaxPackets", UintegerValue(1000000));
clientApps.Add (dlClient.Install (remoteHost));
clientApps.Add (ulClient.Install (ueNodes.Get(u)));
if (u+1 < ueNodes.GetN ())
{
clientApps.Add (client.Install (ueNodes.Get(u+1)));
}
else
{
clientApps.Add (client.Install (ueNodes.Get(0)));
}
}
serverApps.Start (Seconds (0.01));
clientApps.Start (Seconds (0.01));
lteHelper->EnableTraces ();
// Uncomment to enable PCAP tracing
AsciiTraceHelper ascii;
p2ph.EnableAsciiAll(ascii.CreateFileStream("lab5.tr");
p2ph.EnablePcapAll("lena-epc-first");
Simulator::Stop(Seconds(simTime));
Simulator::Run();
/*GtkConfigStore config;
config.ConfigureAttributes();*/
Simulator::Destroy();
return 0;
}